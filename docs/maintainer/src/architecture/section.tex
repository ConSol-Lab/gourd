\pagebreak


\section{Architecture}\label{sec:architecture}

\subsection{Structural Overview}

This section explains each part of the application's modular layout and the technologies used.


\subsection{Postprocessing}
note: should be in user docs.
To postprocess the output of the runs, there are two options available: afterscipts and Slurm postprocessing jobs. 
Afterscripts are scripts that run locally and are thus meant for quick and non-complicated 
postprocessing. On the contrary, for long and complicated postprocessing, there are Slurm postprocessing jobs.
A run can have both an afterscript and a postprocessing Slurm job.

\subsubsection{Afterscripts}
An afterscript is optional and specified per program. To indicate the use of an afterscript, the path to the script 
file needs to be specified in the gourd.toml under the chosen program. Multiple programs can use the same script.
Furthermore, if at least one program has an afterscript, a path to a folder that will store the afterscript output 
needs to be specified (once for the entire experiment, analogous to metrics and output). The afterscript can be used 
to assign labels to runs as a means of specifying custom status.

An afterscript should take two arguments - the path to the input file and the path to a folder for output. The output 
folder is created and is empty. It is the responsibility of the afterscript to create and write to any files in that 
directory.

\subsubsection{Postprocessing Slurm jobs}
A postprocesing Slurm job (further called "postprocessing job") is optional and specified per program. To indicate 
the use of a postprocessing job, a program needs to be specified under "postprocessing programs" in gourd.toml. 
That program will have the path to the postprocessing binary file. In addition, the name of this new postprocesing 
program needs to be specified in the gourd.toml under the chosen regular program to indicate that this is the 
postprocessing used. Multiple programs can use the same postprocessing program. Furthermore, if at least one program 
has a postprocessing job, a path to a folder that will store the postprocesing job output needs to be specified 
(once for the entire experiment, analogous to metrics and output). 

\subsubsection{Example gourd.toml with postprocessing}

\begin{verbatim}
wrapper = "./gourd_wrapper"
output_path = "./exp/outputs"
metrics_path = "./exp/results"
experiments_folder = "./exp/experiments"
afterscript_output_folder = "./exp/after"
postprocess_job_output_folder = "./exp/post"

[postprocess_resource_limits]
time_limit.secs = 60
time_limit.nanos = 0
cpus = 1
mem_per_cpu = 512

[resource_limits]
time_limit.secs = 60
time_limit.nanos = 0
cpus = 1
mem_per_cpu = 512

[slurm]
experiment_name = "this is my experiment"
partition = "compute"
array_count_limit = 1
array_size_limit = 10
account = "Education-EEMCS-MSc-CS"

[programs.testprogram1]
binary = "./test"
arguments = []
postprocess_job = "post1"

[programs.testprogram2]
binary = "/usr/bin/sleep"
arguments = []
afterscript = "./afterscript.sh"

[inputs.testrun1]
input = "./inp"
arguments = ["1"]

[inputs.testrun2]
input = "./inp"
arguments = ["2"]

[inputs.testrun3]
input = "./inp"
arguments = ["3"]

[inputs.testrun4]
input = "./inp"
arguments = ["4"]

[postprocess_programs.post1]
binary = "./post"
arguments = []

\end{verbatim}

\subsection{Labels}
note: this is going to be moved to user docs.
I am temporarily putting it here just so the documentation exists.
Whoever moves this to user guides (lucas told me he will do it) is also responsible for styling the code blocks :)

When running \verb|gourd status|, by default the statuses only display information about Slurm scheduling of the run or an exit code.
In the case that a job execution can succeed (exit code 0) but the run should still be considered a failure, the user can add a custom label to the run, derived from the output of the run's afterscript.
Labels can be created in the configuration file as names with a regular expression, where if the regex has a match in the afterscript's output, then this label is assigned to the run.
Syntax is as follows:

\texttt{gourd.toml}
\begin{verbatim}
    [label.<label_name>]
    regex = <regex>
    priority = <int>
    rerun_by_default = <true/false>
\end{verbatim}
\begin{itemize}
    \item \verb|<label_name>|: The name of the label as is to be displayed by \verb|gourd status|.
    \item \verb|<regex>|: The regular expression to match against the afterscript's output.
    If a match is found, the label is assigned to the run.
    \item \verb|<int>|: The priority of the label.
    Higher numbers have higher priority.
    If multiple labels match the afterscript's output, the label with the highest priority is assigned to the run.
    Multiple labels with the same priority are assigned to the run is undefined behaviour (I think they are ordered alphabetically by name's hash).
    \item \verb|<true/false>|: Including this is optional, with a default value of \verb|true|.
    If the field is not present or present with value \verb|true|, the run will be rerun by default if this label is assigned to it; ie this will be considered a failed run.
    If false then \verb|gourd status| will display the run as successful, and \verb|gourd rerun failed| will ignore it.
\end{itemize}
Labels are assigned based on priority.
For example if the configuration file looks like:
\begin{verbatim}
    [label.label1]
    regex = "Success"
    priority = 1
    rerun_by_default = false

    [label.label2]
    regex = "RuntimeException"
    priority = 2
\end{verbatim}
and the afterscript output looks like:
\begin{verbatim}
    Starting afterscript...
    Success! The output was correct.
    Verifying something else...
    RuntimeException thrown while parsing
\end{verbatim}
then by principle of priorities, the run will be assigned label2 even though both regex match.