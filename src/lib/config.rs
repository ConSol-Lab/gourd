use std::collections::BTreeMap;
use std::path::Path;
use std::path::PathBuf;

use anyhow::Context;
use anyhow::Result;
use serde::Deserialize;
use serde::Serialize;

use crate::constants::AFTERSCRIPT_DEFAULT;
use crate::constants::AFTERSCRIPT_OUTPUT_DEFAULT;
use crate::constants::PRIMARY_STYLE;
use crate::constants::WRAPPER_DEFAULT;
use crate::error::ctx;
use crate::error::Ctx;
use crate::file_system::read_utf8;

/// A pair of a path to a binary and cli arguments.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Program {
    /// The path to the executable.
    pub binary: PathBuf,

    /// The cli arguments for the executable.
    pub arguments: Vec<String>,

    /// The configuration for the afterscript, if there is one.
    pub afterscript: Option<AfterscriptConf>,
}

/// Configuration for an afterscript on a job
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AfterscriptConf {
    /// The path to afterscript output for basic postprocessing.
    #[serde(default = "AFTERSCRIPT_OUTPUT_DEFAULT")]
    pub out: PathBuf,
    /// The path to afterscript for basic postprocessing.
    #[serde(default = "AFTERSCRIPT_DEFAULT")]
    pub src: PathBuf,
}

/// A pair of a path to an input and additional cli arguments.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Input {
    /// The path to the input.
    pub input: PathBuf,

    /// The additional cli arguments for the executable.
    pub arguments: Vec<String>,
}

/// A config struct used throughout the `gourd` application.
//
// changing the config struct? see notes in ./tests/config.rs
// 1. is the change necessary?
// 2. will it break user workflows?
// 3. update the tests
// 4. update the user documentation
#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct Config {
    //
    // Basic settings.
    //
    /// The path to a folder where the experiment output will be stored.
    pub output_path: PathBuf,

    /// The path to a folder where the metrics output will be stored.
    pub metrics_path: PathBuf,

    /// The path to a folder where the experiments will be stored.
    pub experiments_folder: PathBuf,

    /// The list of tested algorithms.
    pub programs: BTreeMap<String, Program>,

    /// The list of inputs for each of them.
    pub inputs: BTreeMap<String, Input>,

    /// If running on a SLURM cluster, the job configurations
    pub slurm: Option<SlurmConfig>,

    //
    // Advanced settings.
    //
    /// The command to execute to get to the wrapper.
    #[serde(default = "WRAPPER_DEFAULT")]
    pub wrapper: String,
}

/// The config options when running through Slurm
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct SlurmConfig {
    /// The name of the experiment. This is used (parametrically) as the job name in SLURM, and for the output directory.
    pub experiment_name: String, // not sure if we need this user-provided or generated by gourd, but it's one of the options and i couldn't tell if it's mandatory or not

    /// Which node partition to use. On DelftBlue, the options are:
    /// - "compute"
    /// - "compute-p2"
    /// - "gpu"
    /// - "gpu-a100"
    /// - "memory"
    /// - "trans"
    /// - "visual"
    pub partition: String, // technically this would be an enum, but it's different per cluster so i don't know if we should hardcode delftblue's options

    /// Maximum time allowed _for each_ job.
    pub time_limit: String, // this is a string because slurm jobs can be longer than 24h, which is the largest value in toml time. format needs to be either "days-hours:minutes:seconds" or "minutes"

    /// CPUs to use per job
    pub cpus: usize,

    /// Memory in MB to allocate per CPU per job
    pub mem_per_cpu: usize,

    /// Where slurm should put the stdout and stderr of the job.
    pub out: Option<PathBuf>,
}

// An implementation that provides a default value of `Config`,
// which allows for the eventual addition of optional config items.
impl Default for Config {
    fn default() -> Self {
        Config {
            output_path: PathBuf::from("run-output"),
            metrics_path: PathBuf::from("run-metrics"),
            experiments_folder: PathBuf::from("experiments"),
            wrapper: WRAPPER_DEFAULT(),
            programs: BTreeMap::new(),
            inputs: BTreeMap::new(),
            slurm: None,
        }
    }
}

impl Config {
    /// Load a `Config` struct instance from a TOML file at the provided path.
    /// Returns a valid `Config` or an explanatory `GourdError::ConfigLoadError`.
    pub fn from_file(path: &Path) -> Result<Config> {
        toml::from_str(&read_utf8(path)?).with_context(ctx!(
          "Could not parse {path:?}", ;
          "More help and examples can be found with {PRIMARY_STYLE}man gourd.toml{PRIMARY_STYLE:#}",
        ))
    }
}

#[cfg(test)]
mod tests {
    extern crate tempdir;

    use std::collections::BTreeMap;
    use std::fs::File;
    #[cfg(any(target_os = "linux", target_os = "macos"))]
    use std::fs::Permissions;
    use std::io::Write;
    #[cfg(any(target_os = "linux", target_os = "macos"))]
    use std::os::unix::fs::PermissionsExt;
    use std::path::PathBuf;

    use tempdir::TempDir;

    use super::*;

    /// This test will fail if the semantics of the config struct are changed.
    /// If this is the case, update the documentation and make sure that the
    /// rest of the application reflects these changes.
    #[test]
    fn breaking_changes_config_struct() {
        #[allow(clippy::unnecessary_operation)]
        Config {
            output_path: PathBuf::from(""),
            metrics_path: PathBuf::from(""),
            experiments_folder: PathBuf::from(""),
            wrapper: "".to_string(),
            inputs: BTreeMap::new(),
            programs: BTreeMap::new(),
            slurm: None,
        };
    }

    /// This test will fail if the semantics of the config file are changed.
    /// See above. Is this a valid reason for the user to update their old files?
    /// If you add something to the struct, add it here too.
    #[test]
    fn breaking_changes_config_file_all_values() {
        let dir = TempDir::new("config_folder").expect("A temp folder could not be created.");
        let file_pathbuf = dir.path().join("file.toml");

        let config_contents = r#"
            output_path = "./ginger_root"
            metrics_path = "./vulfpeck/"
            experiments_folder = "./parcels/"

            [programs]

            [inputs]
        "#;
        let mut file = File::create(file_pathbuf.as_path()).expect("A file could not be created.");
        file.write_all(config_contents.as_bytes())
            .expect("The test file could not be written.");

        assert_eq!(
            Config {
                output_path: PathBuf::from("./ginger_root/"),
                metrics_path: PathBuf::from("./vulfpeck"),
                experiments_folder: PathBuf::from("./parcels/"),
                wrapper: "gourd_wrapper".to_string(),
                inputs: BTreeMap::new(),
                programs: BTreeMap::new(),
                slurm: None,
            },
            Config::from_file(file_pathbuf.as_path()).expect("Unexpected config read error.")
        );
        dir.close().unwrap();
    }

    /// This test will fail if the semantics of all REQUIRED values in the config file are changed.
    /// See above. If you add something to the struct, add it here too.
    #[test]
    fn breaking_changes_config_file_required_values() {
        let dir = TempDir::new("config_folder").expect("A temp folder could not be created.");
        let file_pathbuf = dir.path().join("file.toml");

        let config_contents = r#"
            output_path = "./ginger_root"
            metrics_path = "./vulfpeck/"
            experiments_folder = ""

            [inputs]

            [programs]
        "#;
        let mut file = File::create(file_pathbuf.as_path()).expect("A file could not be created.");
        file.write_all(config_contents.as_bytes())
            .expect("The test file could not be written.");

        assert_eq!(
            Config {
                output_path: PathBuf::from("./ginger_root/"),
                metrics_path: PathBuf::from("./vulfpeck"),
                experiments_folder: PathBuf::from(""),
                wrapper: "gourd_wrapper".to_string(),
                inputs: BTreeMap::new(),
                programs: BTreeMap::new(),
                slurm: None,
            },
            Config::from_file(file_pathbuf.as_path()).expect("Unexpected config read error.")
        );
        dir.close().unwrap();
    }

    #[test]
    fn config_nonexistent_file() {
        let dir = TempDir::new("config_folder").unwrap();
        let file_pathbuf = dir.path().join("file.toml");

        if Config::from_file(file_pathbuf.as_path()).is_ok() {
            panic!("Error expected.")
        }

        dir.close().unwrap();
    }

    // Tests on a file without read permissions.
    // The test does not run on Windows because we access Unix-style permissions here.
    #[test]
    #[cfg(any(target_os = "linux", target_os = "macos"))]
    fn config_unreadable_file() {
        let dir = TempDir::new("config_folder").expect("A temp folder could not be created.");
        let file_pathbuf = dir.path().join("file.toml");
        let file = File::create(file_pathbuf.as_path()).expect("A file could not be created.");
        file.set_permissions(Permissions::from_mode(0o000))
            .expect("Could not set permissions of 'unreadable' test file to 000.");

        if Config::from_file(file_pathbuf.as_path()).is_ok() {
            panic!("Error expected.")
        }
        dir.close().unwrap();
    }

    #[test]
    fn config_unparseable_file() {
        let dir = TempDir::new("config_folder").expect("A temp folder could not be created.");
        let file_pathbuf = dir.path().join("file.toml");

        File::create(file_pathbuf.as_path()).expect("A file folder could not be created.");

        if Config::from_file(file_pathbuf.as_path()).is_ok() {
            panic!("Error expected.")
        }
        dir.close().unwrap();
    }

    #[test]
    fn config_ok_file() {
        let dir = TempDir::new("config_folder").expect("A temp folder could not be created.");
        let file_pathbuf = dir.path().join("file.toml");

        let conf = Config::default();
        let out = toml::to_string(&conf)
            .expect("The default Config could not be serialized for testing.");

        let mut file = File::create(file_pathbuf.as_path()).expect("A file could not be created.");
        file.write_all(out.as_bytes())
            .expect("The test file could not be written.");

        assert_eq!(
            conf,
            Config::from_file(file_pathbuf.as_path()).expect("Unexpected config read error.")
        );
        dir.close().unwrap();
    }
}
